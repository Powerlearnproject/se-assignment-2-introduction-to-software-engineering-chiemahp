[![Review Assignment Due Date](https://classroom.github.com/assets/deadline-readme-button-24ddc0f5d75046c5622901739e7c5dd533143b0c8e959d652212380cedb1ea36.svg)](https://classroom.github.com/a/-ucQIGTc)
[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-718a45dd9cf7e7f842a935f5ebbe5719a5e09af4491e668f4dbf3b35d5cca122.svg)](https://classroom.github.com/online_ide?assignment_repo_id=15219149&assignment_repo_type=AssignmentRepo)
# SE-Assignment-2
Assignment: Introduction to Software Engineering
Instructions:
Answer the following questions based on your understanding of software engineering concepts. Provide detailed explanations and examples where appropriate.

Questions:
Define Software Engineering:
Software engineering is the branch of computer science that deals with the design, development, testing, and maintenance of software applications.

What is software engineering, and how does it differ from traditional programming?
Software Development Life Cycle (SDLC):
SDLC  is a step by step process of developing a software. It include the following phases such as: planning, analysis, design,development, testing, implementation, and maintenance.

Explain the various phases of the Software Development Life Cycle. Provide a brief description of each phase.
Agile vs. Waterfall Models:

Agile is open to adaptation, encourages experimentation and welcomes changes of direction, even in later phases of the project. Because of this, the budget tends to be more flexible. 
Waterfall is a linear project progression, so it's best suited for projects with a defined end goal.

Compare and contrast the Agile and Waterfall models of software development. What are the key differences, and in what scenarios might each be preferred?
Requirements Engineering:

Agile methodology is characterized by its iterative and flexible approach to software development. It emphasizes collaboration among cross-functional teams and prioritizes adaptability to changing requirements throughout the development process.
The Pros:

    Flexibility: Agile allows teams to adapt to changing requirements and priorities, ensuring the final product meets the evolving needs of stakeholders.
    Faster Delivery: By breaking down the project into smaller increments, Agile enables faster delivery of working software, leading to quicker feedback and validation.
    Collaboration: Agile fosters collaboration among team members, promoting better communication and transparency throughout the development cycle.
    Continuous Improvement: The iterative nature of Agile encourages continuous improvement, as teams regularly assess their progress and make necessary adjustments based on feedback.

The Cons:

    Predictability: Agile may struggle with maintaining predictability in project timelines and budgets, as requirements evolve over time.
    Stakeholder Involvement: Agile requires active involvement from stakeholders and dedicated resources, which may not always be feasible.
    Scope Management: Agile is less suitable for projects with fixed scope and strict deadlines, as changes in requirements can impact project scope and timelines.

The Waterfall Methodology

Waterfall methodology follows a linear and sequential approach to software development, with distinct phases such as requirements gathering, design, implementation, testing, and maintenance.
The Pros:

    Clear Roadmap: Waterfall provides a clear roadmap for project execution, making it easier to plan and estimate resources and timelines upfront.
    Stability: Well-suited for projects with stable requirements and predefined objectives, Waterfall ensures thorough documentation and adherence to established processes.
    Predictability: Waterfall offers predictability in project timelines and budgets, as requirements are defined upfront and changes are minimized during development. 

The Cons:

    Rigidity: The rigidity of Waterfall can be a drawback when faced with evolving requirements, making it challenging to accommodate changes late in the development cycle.
    Flexibility: Waterfall lacks the flexibility of Agile to adapt to changes quickly, potentially leading to delays or rework if issues arise.
    Limited Feedback: Due to its sequential nature, Waterfall may limit feedback opportunities until later stages of development, increasing the risk of delivering a product that doesn't meet stakeholder expectations.

Choosing Between Agile and Waterfall

When deciding between Agile and Waterfall, consider the specific needs and characteristics of your project and its needs:
When Agile is ideal:

    Ideal for dynamic environments or projects with evolving requirements.
    Suitable for startups, innovative products, and continuous improvement initiatives.
    Requires active stakeholder involvement and dedicated resources.

When Waterfall is ideal:

    Preferable for projects with well-defined requirements and strict budgets or deadlines.
    Commonly used in government contracts, large-scale infrastructure projects, and industries with regulatory compliance needs.
    Offers predictability in project timelines and budgets, but may struggle with accommodating changes late in the development cycle.

What is requirements engineering? Describe the process and its importance in the software development lifecycle.
Software Design Principles:

Requirements engineering plays a crucial role in the software development life cycle (SDLC) by defining and understanding the customer's needs and desires, as well as facilitating communication 
between stakeholders and the development team.It helps software engineers better comprehend the problem they are working on and supports requirements validation.

Requirements engineering involves tasks such as requirement analysis, elicitation, documentation, conciliation, and validation.The use of automated requirement engineering tools improves communication 
and collaboration among client stakeholders and engineers, even when they are not in the same geographic location . It also helps in writing accurate and complete test requests and test cases. 
Overall, requirements engineering ensures that software requirements are collected with care and helps in creating secure and successful software products that meet customer needs and expectations.


Explain the concept of modularity in software design. How does it improve maintainability and scalability of software systems?Testing in Software Engineering:

Modularity in software design is a technique where complex software is divided into smaller, independent modules, such as functions, classes, or components. It facilitates easier management and understanding of complex systems by breaking them down into digestible parts.

Ease of Reading: Software becomes more readable as it's separated into specific functions handling distinct aspects of the overall functionality.
Simpler Testing: Testing is more straightforward and detailed when focusing on smaller, singular-function modules.
System Focus: Developers can concentrate on individual system parts without affecting the entire system, enhancing development efficiency.
Code Organization: Grouping similar functions into files and libraries makes finding specific code easier, streamlining development.

Modularity can significantly enhance both maintenance and scalability of software. By dividing software into distinct modules, developers can manage, update, and scale parts of the application independently, leading to more efficient maintenance and easier scalability.

    Maintenance Efficiency: Isolating issues within specific modules simplifies debugging and updating processes.
    Scalability: Modular designs allow for adding, updating, or scaling specific modules without impacting the entire system.
    Adaptability: Modular systems can more readily adapt to changing requirements or technologies.
    Collaborative Development: Modularity supports concurrent development, where multiple teams can work on different modules simultaneously.

Describe the different levels of software testing (unit testing, integration testing, system testing, acceptance testing). Why is testing crucial in software development?
Version Control Systems:

In software testing, there are four levels of testing: Unit testing, Integration testing, System testing, and Acceptance testing. These four levels of 
testing must be completed before the software is released, as these testing levels add value to the software development life cycle (SDLC).

Let’s explore each of these levels of testing in detail, along with their primary objective, advantages, and disadvantages. 
Unit Testing

Unit testing is the first level of testing. This testing is the most basic type of testing done by the developers before handing the software/product to the testing team.
Unit Testing Definition: Unit testing is a type of software testing in which individual units or components of the software are tested.
Primary Objective: The main objective of unit testing is to isolate each component of the software and then perform tests to illustrate that every individual component is accurately meeting the requirements and delivering the expected output.

What are version control systems, and why are they important in software development? Give examples of popular version control systems and their features.Software Project Management:

Version control is defined as a system that tracks the progress of code across the software development lifecycle and its multiple iterations – which maintains a record of every change complete with authorship, timestamp, and other details – and also aids in managing change.

The process of monitoring and managing changes to software code is known as version control, also sometimes referred to as revision control or source control systems. Software technologies called version control systems assist software development teams in tracking changes to source code over time.

Version control systems enable software teams to operate more swiftly and intelligently as development environments have increased. They are beneficial for DevOps teams because they will allow them to speed up successful deployments and reduce development time.

Version control pinpoints the trouble spots when developers and DevOps teams work concurrently and produce incompatible changes so that team members can compare differences or quickly determine who committed the problematic code by looking at the revision history. Before moving on with a project, a software team can use version control systems to resolve a problem.

Software teams can understand the evolution of a solution by examining prior versions through code reviews. Every alteration to the code is recorded by version control software in a particular type of database. If an error is made, developers can go back in time and review prior iterations of the code to remedy the mistake while minimizing disturbance for all team members.

1. IBM Configuration Management Version Control (CMVC)

Software that carries out software version control, configuration management, and change management tasks is known as Configuration Management Version Control (CMVC). This system was client-server based, with servers for several Unix flavors and command-line and graphical clients for many platforms. Even after renaming a file, it can track file history. This is because developers may alter the database filename and the filename on the disk was a number. Delegating power is possible thanks to its decentralized administration.
2. Git

Git is among the most powerful version control programs now on the market. The creator of Linux, Linus Torvalds, created the distributed version control system known as Git. Its memory footprint is minimal and can follow changes in any file. When you add this to its extensive feature set, you get a full-featured version control system that can handle any project. Due to its simple workflow, it is employed by Google, Facebook, and Microsoft.
3. Apache Subversion

A version control system called Apache Subversion, which is free and open-source, enables programmers to manage both the most recent and previous iterations of crucial files. It can track modifications to source code, web pages, and documentation for large-scale projects. Subversion’s main features are workflow management, user access limits, and cheap local branching. Both commercial products and individual projects can be managed using Subversion, a centralized system with many powerful features. It is one of Apache’s many open-source solutions, like Apache Cassandra.
4. Azure DevOps

You can utilize all Azure DevOps services or just the ones you require to improve your current workflow. A group of software development technologies you can use in conjunction is Azure DevOps Server, formerly Team Foundation Server (TFS). In addition to access controls and permissions, bug tracking, build automation, change management, collaboration, continuous integration, and version control are all elements of the source code management program known as Azure DevOps Server.
5. Concurrent Versions System (CVS)

One of the first version control systems developed, CVS is a well-known tool for open-source and commercial developers. You can use it to check in and out the code you intend to work on. Teams can integrate their code modifications and add distinctive features to the project. CVS uses delta compression to effectively compress version differences and a client-server architecture to manage change data. In larger projects, it saves a lot of disk space.

See More: What Is Serverless? Definition, Architecture, Examples, and Applications
6. Mercurial

Developers and businesses adore Mercurial for its search capabilities, backup system, data import and export, project tracking and management, and data migration tool. The free source control management program Mercurial supports all popular operating systems. It is a distributed versioning solution and can easily manage projects of any size. Through extensions, programmers can quickly expand the built-in functionality. For software engineers, source revisioning is made simpler by its user-friendly and intuitive interface.
7. GitHub

Software development teams may collaborate and keep track of all code changes using GitHub. You can keep track of code modifications, go back in time to correct mistakes, and collaborate with other team members. The most reliable, secure, and scalable developer platform in the world is GitHub. You receive the best resources and services to assist you in creating the most cutting-edge communities possible. The most reliable, secure, and scalable developer platform in the world is GitHub.
8. AWS CodeCommit

Private Git repositories are hosted by the managed version control system AWS CodeCommit. It smoothly integrates with other Amazon Web Services (AWS) products, and the code is hosted in secure AWS settings. Therefore, it’s a suitable fit for AWS’s current users. Access to various helpful plugins from AWS partners is also made available through AWS integration, aiding in program development. You don’t have to worry about maintaining or scaling your source control system when you use CodeCommit.
9. Bitbucket

As a component of the Atlassian software family, Bitbucket can be connected with other Atlassian products like HipChat, Jira, and Bamboo. Some of Bitbucket’s key features are code branches, in-line comments and debate, and pull requests. The company’s data center, a local server, or the cloud can all be used for its deployment. With Bitbucket, you can freely connect with up to five people. This is advantageous because you can use the platform without spending any money.
10. RhodeCode

RhodeCode is a platform for managing public repositories. RhodeCode offers a contemporary platform with unified security and tools for any version control system, in contrast to old-fashioned source code management systems or Git-only tools. 

The platform is designed for behind-the-firewall enterprise systems that require high levels of security, sophisticated user management, and standard authentication. RhodeCode has a convenient installer, it may be used as a standalone hosted program on your server, and its Community Edition is unrestrictedly free.
11. Computer Associates Panvalet

CA Panvalet establishes and maintains a control library of source programs, centralizes the storage of the source, and offers quick access for maintenance, control, and protection against loss, theft, and other perils. Like Microsoft Visual SourceSafe for personal computers, Panvalet is a closed-source, proprietary system for controlling and versioning source code. Users check out files to edit and then check them back into the repository using a client-server architecture.
12. Helix Core

It offers the sole source of accuracy for all development. The company behind it is Perforce Software Inc. It is a networked client-server revision control tool. It supports several operating systems, including OS X, Windows, and Unix-like platforms. This tool is primarily used in large-scale development setups. Through the tracking and management of changes to source code and other data, it streamlines the development of complicated products. Your configuration changes are branched and merged using the Streams feature.
13. GNU Bazaar

GNU Bazaar (formerly Bazaar-NG Canonical) is a command-line utility by the company that created Ubuntu, and it is a distributed and client-server revision control system. Numerous contemporary projects use it, including MySQL, Ubuntu, Debian, the Linux Foundation, and Debian. GNU Bazaar is truly cross-platform, running on every version of Linux, Windows, and OS X. High storage efficiency, offline mode support, and external plugin support are some of GNU Bazaar’s finest qualities. Additionally, it enables a wide range of development workflows.

Discuss the role of a software project manager. What are some key responsibilities and challenges faced in managing software projects?Software Maintenance:
Managers of software projects supervise and prioritize development work, as well as interact with customers. This requires using project management concepts, such as identifying roadblocks, holding team members responsible, communicating effectively, and providing feedback.

Following are Project manager roles and responsibilities in software development.

   1 Scope Definition

The primary responsibility of a software project manager is to determine the project’s scope. Software development cannot be effective without a clear outline of timeframes, timetables, project styles to utilize, predictions, available resources, and overall objectives.

A project manager is responsible, with the assistance of a qualified team, for establishing these unambiguous terms at the outset, at regular intervals, and the conclusion of the product development life cycle.

   2 Coordination of a Project

A project manager is supposed to be able to organize business and third-party personnel to guarantee the flawless completion of the project.

This entails ensuring that all projects are delivered on time while ensuring that the spent resources adhere to the project’s scope and expenditures stay under budget.

   3 Resource Assignment

A project manager must be able to allocate resources effectively to increase production while decreasing waste to manage resources properly. Expert resource allocation is one of the roles of a project manager in software development.

   4 Change Management

Expectedly, unanticipated occurrences will need modifications to a project plan. The project manager must identify and resolve these changes early on. This demands a degree of foresight and the capacity to be adaptable and flexible in the face of required adjustments, even if they are inconvenient.

   5 Project Execution

Moreover, a project manager is supposed to be capable of project execution. A software project manager’s collective responsibility is to ensure a project’s practical completion.
Project Manager and Software Development

A project manager must assume many duties. A project manager plays an important role in every software development company as they fulfils several roles in delivering projects successfully.

Some responsibilities of a software engineering project manager include the following:

   6 Planning and Organizing

Project managers are responsible for planning and coordinating the software development process. Even though this is never a one-person job and that assistance from a team is always necessary, a project manager stays at the heart of all the planning and organizing that takes place in the lead-up to and during a project.

  7 Instructing

As previously said, a project manager must have a basic understanding of everything. This is because you sometimes need to be on board with new developers and explain where the previous developer left off. To be able to act as a coach, offer them a hand, or act as a guide, you must also be familiar with their work responsibilities.

   8 Supervising

A project manager controls all departmental functions throughout a project’s life cycle. This requires extensive collaboration between teams. The front end, the back end, design, and quality assurance must all be coordinated. Typically, it is the PM who ensures that something occurs. Strong supervision abilities are an essential need for every project manager.

   9 Recruiting

Staffing is hiring employees by evaluating their knowledge and abilities before onboarding and job delegation. To function in the capacity of staffing, a project manager must have human resource and people management abilities. This requires them to understand the skills necessary to fill specific tasks and the characteristics to look for in each recruit.

   10 Project Management

A project manager should understand how to handle projects. A professional project coordinator has the intrinsic capacity to manage each gear that makes up a project’s wheel by effectively managing its people, time, and financial resources. The ultimate responsibility of a project manager is to see a project through to its conclusion.
Conclusion

A project manager is an asset to the project development strategies of any organization. Due to the complexity of a software project manager’s functions and responsibilities, having one oversee a project’s life cycle is crucial for several reasons.

Define software maintenance and explain the different types of maintenance activities. Why is maintenance an essential part of the software lifecycle?Ethical Considerations in Software Engineering:

The software maintenance process involves various software maintenance techniques that can change according to the type of maintenance and the software maintenance plan in place. 

Most software maintenance process models include the following steps:

1.    Identification & Tracing – The process of determining what part of the software needs to be modified (or maintained). This can be user-generated or identified by the software developer itself depending on the situation and specific fault.
2.    Analysis – The process of analyzing the suggested modification including understanding the potential effects of such a change. This step typically includes cost analysis to understand if the change is financially worthwhile.
3.    Design – Designing the new changes using requirement specifications 
4.    Implementation – The process of implementing the new modules by programmers.
5.    System Testing – Before being launched, the software and system must be tested. This includes the module itself, the system and the module, and the whole system at once. 
6.    Acceptance Testing- Users test the modification for acceptance. This is an important step as users can identify ongoing issues and generate recommendations for more effective implementation and changes. 
7.    Delivery – Software updates or in some cases new installation of the software. This is when the changes arrive at the customers. 

The importance of software maintenance
1. Bug-free

Software maintenance packages provided by vendors offer protection by keeping you covered for bugs and software problems. To be more exact, maintenance programs allow your software to stay in warranty so you do not have to come up with cash should an error occur. Implementing the right software system is a long term investment and maintaining an active warranty will help to ensure this.
2. Improved performance with regular upgrades

Most maintenance programs will include an upgrade component. Considering the overall cost of upgrades over time, this component of software maintenance is often all that is necessary to make the program worthwhile. If you had any custom work done as part of your original implementation and purchase, make sure to check that this custom work will also be upgraded, and not at an additional cost.
3. Adaptive to the environment using the software maintenance

Technology and the business environment are two of the fastest-changing aspects of our world. It is increasingly important to ensure that your business is always taking advantage of your software matching the business requirements of the time. Regular updates and software maintenance will allow you to keep up with software development trends and ensure your business is as efficient and effective as it can be.
4. Predictive cash flow

What are some ethical issues that software engineers might face? How can software engineers ensure they adhere to ethical standards in their work?

Addictive design
Every developer yearns to create applications that people love to use -- that's just good UX design. The problem is that some teams craft apps that people love too much. There is an ethical concern about the role of digital platforms, such as social media.

Application security is growing in importance as software plays a larger role in our online and offline environments.

Developers often only address security after code release, rather than during development. As a result, the software community lacks secure development standards. "The emphasis is almost entirely on getting a product out to market," said Randolph Morris, CEO of Bit Developers, a software development consultancy. Once a software product is publicly available, the focus shifts to new features and performance optimization, so security continues to have minimal prominence.

Hackers and other malicious actors cause real damage to real people. Our current digital ecosystem tends to address application security by plugging vulnerabilities as they are found. The reactionary approach is neither practical nor pragmatic.

To address this ethical responsibility for customer safety, developers need education, but typically only cybersecurity-specific classes address these topics. To start, educate your team about cybersecurity failures such as the Anthem medical data breach in 2015, where PII was stored as plain text in a database. "If this information was encrypted, it would not have been so easy to use and valuable to distribute," Morris said.

Also, the industry needs revised security standards. Organizations can do more to embrace standards meant to protect PII. The Payment Card Industry Data Security Standard and HIPAA for health apps are a good start, but developers should consider other forms of PII as well, and software designs that protect it.
Prioritizing features over impact

At the center of many ethical issues is a decision that capabilities in software releases are more important than the effects they could have. But just because you can doesn't mean you should.

"If the development team is measured on their rate of feature development, there's a high probability that the ethics of a given implementation might not be front of mind, either at the design or at the implementation phase," said Tim Mackey, principal security strategist at Synopsys Cyber Security Research Center. Synopsys is an electronic design automation company.

The business itself must set the tone for ethical standards in its software. Reflect ethics priorities throughout software lifecycle from design to operation. Train staff on ethical choices such as open source software licensing and use. Teach developers, architects, testers and other software team members about data management practices that comply with regulations and customer expectations. Developers don't follow news on the latest legislative actions in the jurisdictions where customers use their software, Mackey pointed out, but the business must ensure they're informed.

Collaboration between engineering leadership and legal teams can avoid ethical shortcomings. For example, the business should focus on customers' personal data access and retention. Data access controls and logging mechanisms are enabled at software implementation time. Developers -- tasked with creating a functional, user-friendly product -- will view data access restrictions as the responsibility of another team. Instead, ensure data protection is a feature included in the software design, inherently protecting against unauthorized access.

Submission Guidelines:
Your answers should be well-structured, concise, and to the point.
Provide real-world examples or case studies wherever possible.
Cite any references or sources you use in your answers.
Submit your completed assignment by [due date].
